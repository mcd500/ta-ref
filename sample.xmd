## Writing a sample trusted application on RISC-V

The purpose of this article is to describe an example trusted application with [Keystone enclave](https://keystone-enclave.org/) which is a research TEE on RISC-V and discuss how typical functions are implemented in the trusted application.

Our example includes some typical functions like:

* get random number
* get times
* make message digest
* protected files
* encryption/decryption with symmetric key
* sign/verify with asymmetric keys

Generally, some of these functions may be implemented with the help of the hardware like random number generator, real time clock, secure storage and some special cryptographic accelerators which can be accessed only with the enclaves to avoid security issues.
In our case, there is no such special hardware and we use the functions given by the rich os via OCALL if needed. As a result, some functions are restrictive compared with the hardware supports and should be carefully handled.

## Trusted application API

There are several exhaustive trusted application APIs. [GlobalPlatform API](https://globalplatform.org/document_types/api/) is the well-known API and [OP-TEE](https://www.op-tee.org/) is an implementation of GlobalPlatform API on ARM TrustZone.
[Intel SGX SDK](https://software.intel.com/en-us/sgx/sdk) gives their API for Intel CPU with Software Guard Extensions.
[Open Enclave SDK](https://openenclave.io/sdk/) defines TEE API which is independent to the base TEEs.
[Google Asylo](https://asylo.dev/) has another portable TEE API.

The implementation of GlobalPlatform API on TrustZone is based on trusted os called OPTEE os. SGX and Keystone<sup>[1](#myfootnote1)</sup> uses very thin runtimes instead of the trused os with the ample functions.

<a name="myfootnote1">1</a>: Keystone uses a thin runtime 'Eyrie' as its standard runtime, though it can be replaced with more rich one, for example, SeL4. See https://github.com/keystone-enclave/keystone-seL4.

This design choice effects how the trusted computation should be done and their attack surfaces, though both will play essentially same role.
Usually trusted os has the rich set of the cryptographic and other functions and has exclusive access rights to security critical resources including special hardwares. On the other hand, thin runtimes give some basic functions only. In the latter case, cryptographic functions will be processed with the enclave itself, not with the trusted os calls.
Generally, the attack surface of the cryptographic computation is in the trusted os on the former system and in the enclave on the latter.

It affects also the number of context switches and data copy required when an operation is done. Generally trusted os doesn't require context switch between the trusted and untrusted worlds and has some advantages in this regard. See the next section OCALL for details. This won't be a problem if the operation to be done is relatively heavy. On the other hand, if all computations are done in the enclave instead of the trusted os calls, it's more efficient than the computation using trusted os call. So for the thin runtime case, it would be better to compute in the enclave and reduce OCALLs as much as possible.

## OCALL

There are several forms of communication between normal applications and enclaves. OCALL which means 'out call' is a typical one with some function call like interface that an enclaves can call some normal world function. There are systems which have functions with the inverse direction. SGX's normal application can call an enclave function with ECALL. [Fig.1](http://192.168.100.100/vc707/junkyard/blob/master/ocall-howto.pdf) shows how OCALL works in Keystone with a simple example.

There are two glue codes both in the application and the enclave.
Each glue code wraps the edge/boundary system call and serializes/deserializes the arguments/results. These wrapper codes should be crafted very carefully because they are put at the attack surfaces. See [A Tale of Two Worlds: Assessing the Vulnerability of Enclave Shielding Runtimes](https://people.cs.kuleuven.be/~jo.vanbulck/ccs19-tale.pdf).

These wrapper codes have rather fixed patterns and usually are generated with the tool called edger. SGX has edger8r as its edger tool and Open Enclave uses oeedger8r which is a modified version of edger8r. Recently, Keystone adds keyedge as its edger. All edgers generate glue codes from annotated function. edger8r/oeedger defines Enclave Definition Language (EDL) for this purpose. Keyedge uses simple annotations which will be ignored with the normal compilation.


```
  [edger8r syntax in .edle]

    untrusted {
        unsigned int ocall_print_string([in, string] const char *str);
    };


  [keyedge syntax in .h]
  
    unsigned int ocall_print_string(keyedge_str const char* str);

```


Keyedge uses the LLVM infrastructure to analyze the syntax and the flatcc library to serialize/deserialize the data. edger8r/oeedger8r is written by ocalm and has its own analyzer/serializer/deserializer. edger8r is relatively easy to port for the other systems. oeedger8r is an example and we also have ported it to Keystone and used it internally before keyedge was released. All edgers generate wrapper codes which sanitize the arguments and the results, though there maybe yet unknown issues as "A Tale of..." shows.

## Emulation of secure storage

Our example enclave gives minimal and typical interfaces which are common for OPTEE, SGX and Keystone. Supported cryptographic operations are 256bit AES CBC/GCM, SHA3 digest and ed25519 sign/verify only. OPTEE gives these functions with their API. For Keystone and SGX, we use cryptographic libraries, though SGX prepares some of these functions in SDK.

OPTEE gives random number and time functions with its standard API. SGX defines these functions in the standard library, though the secure time function can work only on Windows system at the moment. Keystone has no secure random and time functions yet.

The one problematic API is the secure storage API. OPTEE assumes the existence of real secure storage supported by hardware. We use encrypted normal files to emulate the secure storage for SGX and Keystone because we couldn't assume such hardware for them. The file contents are encrypted with AES CBC. The file i/o operations are done with OCALLs. The AES key should be persistent and unpredictable. This scheme gives many restrictions and some issues on API.

* Read/write is permitted only when the data size is a multiple of 16.
* Open with RW mode isn't supported. Storage(persistent object) should be opened with write-only mode or read-only mode.
* It can't be opened with the append mode. If you want to append something to the object, you have to read all content and write the appended one.

The key and initial vector (iv) cause other implementation issue. The ideal key and initial vector are hard to get in the usual Keystone environment. We use attestation report as the last resort. SGX has sgx_get_key function which is essentially a wrapper of EGETKEY/EREPORT instruction and uses it for file encryption. Keystone/SGX report is enclave/system invariant which depends on some given data. With using objectID (file name) as that data, it returns an enclave/system/objectID invariant. We deduce the key and the initial vector from this invariant.
We use the signature part of the report as key and the iv is got as a digest of the report. It means that the iv correlates with the key. This will reduce the endurance against the brute force, though the iv changes with the enclave and objectID.
Those keys add another constraints on Persistent objects. 

* An object can be accessed with only one enclave.
* Changes of system could make all persistent objects obsolete.

Changes of BIOS (SGX) or Secure Monitor (Keystone) will give the different signature even for same enclave.

Rollback attack is the another issue. There is no mechanism to avoid rollback attack with our current implementation. The user must update ObjectID or some data in the enclave like the version id explicitly for the new contents. This mitigates rollback attack because key/iv are ObjectID/enclave invariants.

## Performance measurement







## Reference

[ ] Bailleu, Maurice & Dragoti, Donald & Bhatotia, Pramod & Fetzer, Christof. (2019). TEE-Perf: A Profiler for Trusted Execution Environments. 414-421. 10.1109/DSN.2019.00050.

[ ] Google. 2019. Asylo: An open and flexible framework for enclave applications. online, accessed 2019-06-12: https://asylo.dev/. (2019).

[ ] Intel. 2019. Software Guard Extensions SDK. online accessed 2019-06-17: https://software.intel.com/en-us/sgx/sdk/. (2019).

[ ] D. Lee, D. Kohlbrenner, S. Shinde, D. Song, and K. Asanović. 2019. Keystone: AFramework for Architecting TEEs.arXiv preprint arXiv:1907.10119(2019).

[ ] Global Platform. 2019, GlobalPlatform API Archives. online accessed 2019-12-25: https://globalplatform.org/document_types/api/

[ ] Microsoft. 2019. Open Enclave SDK. online, accessed 2019-10-10: https://openenclave.io/sdk/. (2019).

[ ] Jo Van Bulck, David Oswald, Eduard Marin, Abdulla Aldoseri, Flavio D.Garcia, and Frank Piessens. 2019. A Tale of Two Worlds: Assessing the Vul-nerability of Enclave Shielding Runtimes. In2019 ACM SIGSAC Conferenceon Computer and Communications Security (CCS ’19), November 11–15, 2019, London, UK.ACM, New York, NY, USA, 18 pages. https://doi.org/10.1145/3319535.3363206

[ ] OP-TEE.org. 2019. OP-TEE. online, accessed 2019-11-21: https://github.com/OP-TEE/.

